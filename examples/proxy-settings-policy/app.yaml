apiVersion: v1
kind: ConfigMap
metadata:
  name: response-generator
data:
  main.go: |
    package main

    import (
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"
    )

    func coffeeHandler(w http.ResponseWriter, r *http.Request) {
        // Returns a large response to demonstrate buffering requirements
        // This generates a response larger than NGINX's default proxy_buffer_size (4k/8k)
        // Without proper buffering configuration, this may cause errors
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("X-Content-Type-Options", "nosniff")

        // Generate a large header that exceeds default proxy_buffer_size
        // Default is typically 4k-8k depending on platform
        largeHeader := strings.Repeat("X", 10000)
        w.Header().Set("X-Large-Header", largeHeader)

        flusher, ok := w.(http.Flusher)
        if !ok {
            http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
            return
        }

        // Generate a large response body (5MB in chunks)
        // This tests both proxy_buffer_size and proxy_buffers settings
        chunkSize := 1024     // 1KB chunks
        totalChunks := 5120   // 5MB total

        for i := 0; i < totalChunks; i++ {
            chunk := fmt.Sprintf("Coffee chunk %d: %s\n", i, strings.Repeat("x", chunkSize-20))
            fmt.Fprint(w, chunk)
            if i%10 == 0 {
                flusher.Flush()
            }
            time.Sleep(100 * time.Microsecond) // Small delay to simulate slow backend
        }
    }

    func healthHandler(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        fmt.Fprint(w, "OK")
    }

    func main() {
        http.HandleFunc("/coffee", coffeeHandler)
        http.HandleFunc("/health", healthHandler)

        log.Println("Server starting on :8080")
        if err := http.ListenAndServe(":8080", nil); err != nil {
            log.Fatal(err)
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coffee
spec:
  replicas: 1
  selector:
    matchLabels:
      app: coffee
  template:
    metadata:
      labels:
        app: coffee
    spec:
      containers:
      - name: coffee
        image: golang:1.25-alpine
        command: ["/bin/sh"]
        args:
          - -c
          - |
            cd /app
            go run main.go
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: app
          mountPath: /app
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: app
        configMap:
          name: response-generator
---
apiVersion: v1
kind: Service
metadata:
  name: coffee
spec:
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: coffee
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tea
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tea
  template:
    metadata:
      labels:
        app: tea
    spec:
      containers:
      - name: tea
        image: nginxdemos/nginx-hello:plain-text
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: tea
spec:
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: tea
